---
layout: post
title:  "The TLS/SSL v1.2 handshake made simple: session keys generation"
date:   2024-05-27 00:00:00 +0200
categories: blog security-and-access
---
<!--<link rel="stylesheet" href="{{ site.baseurl }}{% link mngassets/posts/2023-09-29-sticky-figure-with-scrollama/2023-09-29-sticky-figure-with-scrollama.css %}">-->
<link rel="stylesheet" href="{{ site.baseurl }}{% link mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/style/scrollama-sidetext.css %}">
<link rel="stylesheet" href="{{ site.baseurl }}{% link mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/style/scrollama-thispost.css %}">


<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS-client2server02.png %}" style="width:100%;">


# The TLS/SSL and the TLS/SSL Handshake: Quick Review

In a [previous post]({{site.baseurl}}{% link _posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos.markdown %}) we made a general introduction of the TLS/SSL protocol, and its role in the security of the internet communications to prevent eavesdropping and tampering.

We also concentrated on the handshake section, specifically the one concerning to the version 1.2 of the protocol, which is described in the following diagram:

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos/img/Full_TLS_1.2_Handshake.png %}" style="width:100%;">
(*source: [Wikipedia](https://en.wikipedia.org/wiki/Communication_protocol)*)

We identified 4 relevant exchanges:

1. When the connection is requested (the TCP/IP connection)
2. The Hellos
3. Client Key Exchange (generation of session keys)
4. The Application Data

We mentioned that we wanted to discuss some aspects of steps 2 and 3.

We listed the main concerned parties: the Client, the Server and the Certificate Authority.

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos/img/TLS - parties.png %}" style="width:100%;">

The whole Handshake protocol focus on those three "participants". In the steps following the Hellos, the Certificate Authority has completed its task and it is now up to the Client and the Server to define how to continue with the following steps.

> Remember that the Client and the Server are **application software**, not real people :) .

# How to keep the communication private across a public channel?

We left our [previous post]({{site.baseurl}}{% link _posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos.markdown %}) at the end of the Server hello, where the Server sent some information to the Client that will be required to create the session keys. All those previous exchanges have been made through public channels, and the content of the information of those exchanges hasn't been a secret to anyone. Someone who captures the messages between those two will get the exactly same copy that the Client and the Server have.

One way to privately communicate through a channel vulnerable to eavesdropping and tampering would be to "hide" the content of the communications by chaging it in a way that make the content impossible to understand but by the involved parties - in our case the Client and the Server. The task of making the information looks like "rubish" is called **encryption**, while restoring it is what is called **decrpyption**, and the same dedicated to the study of those tools is called **cryptography**.

In general, the involved parties would make use of functions called **ciphers** which could be based on **keys** to complete the task.

Let's try to understand the encryption / decryption process and the ciphers by using a very simple example. Just look at the following message. This is my "encrypted" message for you:

#### kutypakutynakutyma

An encrypted message is known as **chiphertext**. Can you get what it is in my ciphertext? It is very easy: just get rid of the fragments that read "kuty" and now it would read "panama". The original message is known as **plaintext**. My ciphertext was the result of inserting the word "kuty" before every syllable of the original plaintext. Decrypting was made possible by inverting that operation.

Now notice that for you to get the plaintext out of my ciphertext you had to know those two things:

* the cipher function ("inserting the word ..."), and
* the key, in this case the word "kuty"

Now, you have to believe that:

> The encryption procedure will stay safe even if the parties have shared full information information about the cipher with third-parites, as long as they are the only ones who know the keys 

Looking at my simple example, this means that you might still have to make some effort to decrypt a new message if I change the word "kuty" for another very difficult word if I don't tell you what the new word is.

However, my simple encryption procedure will still be beatable all day. A more powerful procedure prevents you to infer the cipher function and / or the key by only looking at the ciphertext. The TLS makes use of those more powerful procedures which are based on keys resembling random numbers, and apply more complex mathematical operations over the plaintext that inserting characters in between.

That means that Client and Server can now agree on what cipher they want to use, and then create random numbers as keys and share them through... Ooeps...

What???? Not on the public domain! So even if they can share the cipher on the public space, how they are going to agree over the keys? A phone call? The Post Office? ...?

> ... in order to share that secret part of the key, they need to share it in an encrypted way across a public domain

So how are they going to share that secret section of a key in a way that no-one can read it?

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/1f914.jpg %}" style="width:100%;">

### Client Key Exchange and Generation of Session Keys

Part of the purpose of the hellos was to exchange initial information about which encryption procedures both, the Client and the Server, would like to use.

They also shared some keys that could be exposed to the public domain, but haven't been used yet.

In version 1.2, the generation of the session keys is the step where the Client and the Server begin to share "secrets" and it consists in three phases of encryption.

#### The Assymetric Phase: The Pre-Master Exchange 

In the first phase, once the legitimacy of the Server was confirmed, the Client will encrypt a secret for the Server, the **pre-master secret**. To send that pre-master secret encrypted, the Client will rely on an **asymmetric encryption** procedure.

#### The PRF Phase: The Master Secret and Session Key Generation

The pre-master, even if now only known to Client and Server, might not be totally safe as well as not complying with the requirements for a proper key. Furthermore, the Client as well as the Server would like to get the same key on their corresponding sides.

So they input the pre-master secret through a processing function that will result in an improved key, which will become the **master secret**.

Usually after the master secret is obtained, the pre-master is thrown away and it is that master secret that is used in the following step.

#### The Symmetric Phase: The Finished Exchange

The final goal of this procedure is for both, the Client and the Server, to be able to engage in what is called **symmetric encryption**, which is a procedure where *the same* key can be used to reverse the current cryptographic operation over a message.

Why would they both want to get symmetric? Because the symmetric cryptography is known to be a very fast way to encrypt and decrypt large bulks of data, as well as being more dynamic, not having to rely on the intervention of a third party, like the certificate authority, to validate the keys.

> In practice, a two-way asymmetric procedure has been used for some special cases, like Intranet or IoT

The keys used during the symmetric encryption are popularly known as **session keys**, which are derivates of a single, secret key kept by both parties (guess: *the master secret*). 


# In Action

So you can see now why the asymmetric procedure was used on the first place: it was only to encrypt the (pre) key that will be used for the symmetric procedure, as well as giving some guarantee of identity through a certificate authority.

In case you are still not completely getting a picture of the session key generation, I have prepared a visual step-by-step explanation. For the sake of simplicity I am not focusing on the technical details, which are much more complicated. But once you understand the whole exchange is trying to achieve, then the complex part becomes more accessible.





<section id='scrolly'>
    <figure id="scrollfig"></figure>
    <div class="articlepost">
        <div class='step title' data-step='1'>
            <p class='title'>The Asymmetric Phase</p>
            <div class='subtitle'>
            <p>It is called asymmetric because after an encryption operation, the other side will need a different but related key to decrypt the message.</p>
          </div>
        </div>
        <div class='step' data-step='2'>
            <div class="explain">
            <p>During the asymmetric phase, the parties will make use of the server keys. The Client has a copy of the public one (as possibly everyone else) for encryption, but it is expected that only the Server knows the private key for decryption. The Server is the one who choose the cipher to use.</p>
          </div>
        </div>
        <div class='step' data-step='3'>
            <div class="explain">
            <p>The Client uses the server public key and with an already negotiated asymmetric cipher encrypt the <strong>pre-master secret</strong>, which is another random number, and sends that to the Server.</p>
        </div>
        </div>
        <div class='step' data-step='4'>
        </div>
        <div class='step' data-step='5'>
            <div class="explain">
            <p>Now the Server uses the private key to decrypt the pre-master secret from the Client. The pre-master secret was safely passed through the public domain and now they both finally share their first secret. <strong>The asymmetric phase is completed.</strong></p>
            </div>
        </div>
        <div class='step title' data-step='6'>
         <p class='title'>The PRF Phase</p>
         <div class='subtitle'>
       <p>//DESCRIBE THIS PART AS OCURRING SIMULTANOUESLY ON BOTH SIDES// Both the Server <i>and</i> the Client have the pre-master secret. They want to obtain the <strong>master secret</strong>, which will be a <i>pseudo</i>  random number. But they should ensure that <i>both of them  will arrive to the same pseudo random number</i>. For that they will use a function that will get as input some of the data they already share between them...</p>
         </div>
          </div>
        <div class='step' data-step='7'>
            <div class="explain">
            <p>Inputs for the function will be the client random and the server random (both shared unencrypted during the hello step), and the pre-master secret (which is ideally only known to the Server and the Client). The fact that one of the inputs is a secret to everyone else makes the output of the function unkown to others. Eg. you can not figure out the output of this function:  <code>5 + ... = ?</code></p>
           </div>
        </div>
                <div class='step' data-step='8'>
            <div class="explain">
            <p>The processing function is usually a <strong><a href='https://csrc.nist.gov/glossary/term/pseudorandom_function#:~:text=Definitions%3A,indistinguishable%20from%20truly%20random%20output'>Pseudo Random Function (PRF)</a></strong>, which is a procedure that will result in the same pseudo-random value on the side of the Client as well as the Server, as long as they both apply the same procedure and use the same inputs. The most important here is that <a href='https://stackoverflow.com/a/15413799'>no-one will be able to infer the exact values of the inputs reversibly by obtaining the output of the function</a>, guaranting certain level of safety.</p>
            </div>
        </div>        
        <div class='step' data-step='9'>
            <div class="explain">
            <p>The Server and the Client create and share an identical master secret. //WHY A MASTER//</p>
            </div>
        </div>
        <div class='step' data-step='10'>
            <div class="explain">
            <p>The master secret and the randoms will be used to create the session keys using a similar procedure as for the creation of the master secret. Both parties produce <i>more than one key</i> in a single <strong>key block</strong> that is eventually "sliced" up to the right sizes. The resulting session keys would fit the symmetric cipher previously negotiated between the parties. The keys are ready: <strong>we can move to the next phase</strong>.</p>
            </div>
        </div>
        <div class='step title' data-step='11'>
            <p class="title">The Symmetric Phase</p>
            <div class="subtitle">
            <p>During the symmetric procedure, all that can be encrypted with a encryption key can be decrypted with the same key by reversing the encrypting operation.</p>
            </div> 
        </div>
        <div class='step' data-step='12'>
            <div class="explain">
            <p>The reason why several session keys instead of one is because in practice there are more than one type of communication and more than one communication channel during a single session. Encrypting each type of communication for each channel using different keys adds a higher level of security.</p>
            </div>
        </div>
        <div class='step' data-step='13'>
            <div class="explain">
            <p>Both the Client and the Server will use an agreed symmetric cipher function now with a similar key on each side.</p>
            <p>The Client is the first to test the resulting procedure. The Client encrypts a message ("finished") with test data which would revail if the handshake was tampered, and sends it to the server...</p>
            </div> 
        </div>
        <div class='step' data-step='14'>
        </div>
        <div class='step' data-step='15'>
            <div class="explain">
            <p>If, after receiving and decrypting the ciphertext the Client message was as expected, the Server will respond to the Client with a similar message... </p>
            </div> 
        </div> 
        <div class='step' data-step='16'>
        </div> 
        <div class='step' data-step='15'>
            <div class="explain">
            <p>If the Client gets the message from the Server as expected, then <strong>the handshake is finished</strong>. </p>
            </div> 
        </div>            
    </div>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
</section>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/threejs/v104/three.v104.min.js %}"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/D3js/v7.8.5/d3.v7.min.js %}"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/scrollama/v2.1.2/scrollama.v2.min.js %}"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/stickyfill/v2.1.0/stickyfill.v2.min.js %}"></script>
<script type="module"  src="{{ site.baseurl }}{% link mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/js/scrollama-setup.js %}"></script>
<br/>
<br/>
<br/>



# Tada!

The "tada" moment consists in the beginning and completion of the fourth type of exchange between the parties, the Application Data, with fully encrypted information across a public domain, with no-one able to understand what it reads. Great, eh? 


# Final Remarks

> Notice that for version 1.2 the asymmetric procedure is based on **static keys**; in this case, it will be enough to decrypt the messages. For this reason, and for other ones, the version 1.3 get rid of this step using a different cryptographic procedure

The TLS / SSL handshake is a very fascinating solution to the security on the web. The procedure last just miliseconds, but there are a lot of things going on. That is why this procedure is sometimes difficult to understand.

Here in this post I just focused on a very specific section of the TLS handshake in its more popular version to date. Bear in mind that there is already a new version of the TLS that it is meant to replace the existing one. But this might take a few years from the time of this writing before it is completed faced out.

If you want to know more about the TLS, there is a lot of material you can find online. However, there are two that have impressed me the most:

##### KHAN ACADEMY

An excellent material, with exercises you can do on the fly, and a detailed discussion of the many aspects around the TLS handshake. No many can rival that quality of the material prepared by the Khan Academy team. The material goes beyond the TLS handshake by keeping this topic as a subtitle of Internet Security. Highly recommended.

**Find more at** [Online Data Security in Khan Academy](https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:online-data-security)


##### PRACTICAL NETWORKING

If what you want is to get a deep knowledge of the TLS itself, have a look at the cyphers used in the procedure, and many other details, including the new versions of TLS, you might find Practical Networking channel and courses probably a better choice. 

Practical Networking is a project by Ed Harmoush and it is not only a good youtube channel but also a very good course. Go for this one if you are into nets. Very clear and detailed.

**Find more at** [Practical Networking youtube channel](https://www.youtube.com/@PracticalNetworking)

**Or visit the Ed Harmoush'Sf course**, [Practical Networking course - About -](https://www.practicalnetworking.net/about/)


----

For the rest, I just hope you enjoyed this reading. Meanwhile, happy coding!


# Dumped



