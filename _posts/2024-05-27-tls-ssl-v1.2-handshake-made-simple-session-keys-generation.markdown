---
layout: post
title:  "The TLS/SSL v1.2 handshake made simple: session keys generation"
date:   2024-05-27 00:00:00 +0200
categories: blog security-and-access
---
<link rel="stylesheet" href="{{ site.baseurl }}{% link mngassets/posts/2023-09-29-sticky-figure-with-scrollama/2023-09-29-sticky-figure-with-scrollama.css %}">

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS-client2server02.png %}" style="width:100%;">


# The TLS/SSL and the TLS/SSL Handshake: Quick Review

In a [previous post]({{site.baseurl}}{% link _posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos.markdown %}) we made a general introduction of the TLS/SSL protocol, and its role in the security of the internet communications to prevent eavesdropping and tampering.

We also concentrated on the handshake section, specifically the one concerning to the version 1.2 of the protocol, which is described in the following diagram:

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos/img/Full_TLS_1.2_Handshake.png %}" style="width:100%;">
(*source: [Wikipedia](https://en.wikipedia.org/wiki/Communication_protocol)*)

We identified 4 relevant exchanges:

1. When the connection is requested (the TCP/IP connection)
2. The Hellos
3. Client Key Exchange (generation of session keys)
4. The Application Data

We mentioned that we wanted to discuss some aspects of steps 2 and 3.

We listed the main concerned parties: the Client, the Server and the Certificate Authority.

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos/img/TLS - parties.png %}" style="width:100%;">

The whole Handshake protocol focus on those three "participants". In the steps following the Hellos, the Certificate Authority has completed its task and it is now up to the Client and the Server to define how to continue with the following steps.

> Remember that the Client and the Server are **application software**, not real people :) .

# How to keep the communication private inside a public channel?

We left our [previous post]({{site.baseurl}}{% link _posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos.markdown %}) at the end of the Server hello, where the Server sent some information to the Client that will be required to create the session keys. All those previous exchanges have been made through public channels, and the content of the information of those exchanges hasn't been a secret to anyone. Someone who captures the messages between those two will get the exactly same copy that the Client and the Server have.

One way to privately communicate through a channel vulnerable to eavesdropping and tampering would be to "hide" the content of the communications by chaging it in a way that make the content impossible to understand. The only ones who have the capabilities to restore that "rubish" message into the original one should be our main parties, in this case the Client and the Server. The task of making the information looks like "rubish" is called **encryption**, while restoring it is what is called **decrpyption**. In order to encrypt and decrypt a message, the parties use functions called **ciphers** which could be based on **keys** to complete the task.

Let's try to understand the encryption / decryption process and the ciphers by using a very simple example. Just look at the following message. This is my "encrypted" message for you:

#### kutypakutynakutyma

Can you get what it is in my message? It is very easy: just get rid of the fragments that read "kuty" and now it would read "panama".

My cipher function was indeed that easy: inserting the word "kuty" between the syllables of the actual message. Decrypting was made possible by inverting that operation.

But notice something: for you to get the message you had to understand the pattern I applied to encrypt it. That means, you have to know the function I used to encrypt my message. In other words, **we both must have the same cipher**. Furthermore: **we both must share some usable keys**, i.e. a sort of pattern, or a combination of patterns, that the cipher will use as a base to restore or hide the message.

In this simple example, the word "kuty" was the key. But notice that we can say that "ku" is one part of the key and "ty" is the other one.

Now, you have to believe that:

> As long as both parties share the keys between them and with no-one else, the encryption procedure will stay safe

This means that you might still have to make some effort to decrypt a new message if I change the word "kuty" for another key. It would be easier if I provide you my key in advance, so we both have it.

However, this simple encryption procedure will still be beatable all day. Therefore, if someone was able to get the pattern (the key) just by reading the encrypted word, then my message lost its secrecy and then my message passed unsafe through the channel.

The TLS makes use of more powerful procedures which are based on random numbers as keys, and apply more complex mathematical operations over the message that simply inserting a word.

So, Client and Server can now agree on what cipher they want to use, and then create random numbers as keys and share them through... Ooeps...

Not on the public domain! So even if they can share the cipher on the public space, how they are going to agree over the keys?

Ok, here a hint:

> They will end up using a composite key, and one part of it will be secret to everyone but the Client and the Server. That will be enough to make the whole key secret.

Just for you to understand what I mean, try to get the third element of the following pattern based on **what I am thinking**:

#### A, B, and ...

Are you sure that you got it correctly? You even don't know if I am thinking on an animal, or a city, or anything else. Now, try to XXXXXXXXXXX that in the context of two parties for which everyone got two parts of their key set, but only the two parties know the last one.

but...

> ... in order to share that secret part of the key, they need to share it in an encrypted way

Whaaaaaaaaaaaaaaaaaat?

So how are they going to share that secret section of a key in a way that no-one can read it?

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/1f914.jpg %}" style="width:100%;">

### Client Key Exchange and Generation of Session Keys

Part of the purpose of the hellos was to exchange initial information about which encryption procedures both, the Client and the Server, would like to use.

They also shared some keys that could be exposed to the public domain, but haven't been used yet.

In version 1.2, the generation of the session keys is the step where the Client and the Server begin to share "secrets" and it consists in two phases of encryption.

In the first phase, once the legitimacy of the Server was confirmed, the Client will use a public key to encrypt a secret to the Server, the **Pre-Master secret**. To send that pre-master secret encrypted, the Client will rely on an **asymmetric procedure**.

The Server will get that new key reverting the encryption, and continue with a second phase where the new key together the public ones will be used for a **symmetric encryption / decryption procedure**, which will be the encrypting mechanism for the rest of the communications.

You might ask: Why two phases? Wouldn't the asymmetric phase be enough? Some of the issues here are performance and complexity of the implementation.

The asymmetric mechanism, although very safe, is slow. It would substantially delay the communications when involving large amount of data. It would also be harder for all systems to create and set certified private and public keys for every possible communication.

> In practice, a two-way asymmetric procedure has been used for some special cases, like Intranet or IoT

However, if we assume that just one of the parties is certified for every ocassion, and that we transfer a small amount of data like a random number, than the asymmetric procedure could be a good option.

But for larger data transfers, the parties might prefer a safe encryption / decryption operation that doesn't take that long, and that is something that the symmetric procedure does better than the asymmetric one. It doesn't require certification and can be changed for every new session.

There are three phases during the session keys generation step: 

* The Client Pre-Master Secret Generation and the Asymmetric Encrytion
* The Generation of the Master Secret using a Pseudo-Random Number Generator
* The Generation of the Session Keys for Symmetric Encryption

Let's see some details of how the work.


#### The Asymmetric Phase

It is called asymmetric because after an encryption operation, the other side will need a *different but related key* to decrypt the message.

Do you remember that on the [previous post]({{site.baseurl}}{% link _posts/2024-02-18-tls-ssl-v1.2-handshake-made-simple-hellos.markdown %}) we mentioned the Server public and private keys?

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - asymmetric keys.png %}" style="width:50%;">
<br/>
<br/>
<br/>

So, everyone, including our Client, has a copy of the public key, but *only the Server (should) know the private one*. And that is the base of the success of the decryption procedure: only the Server will be able to decrypt the message of the Client when both using the same encryption / decryption procedure.

> Notice that for version 1.2 the asymmetric procedure is based on **static keys**; in this case, it will be enough to decrypt the messages. For this reason, and for other ones, the version 1.3 get rid of this step using a different cryptographic procedure 

#### The Pseudo Random Function (PRF) for the Master Secret generation



#### The Symmetric Phase

Now both the Server and the Client have a set of keys one of which is a secret shared only between them (the pre-master).

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - symmetric keys.png %}" style="width:100%;">
<br/>
<br/>
<br/>

# In Action

<section id='scrolly'>
    <figure id="scrollfig">
    </figure>
    <div id="test"></div>
    <div class="articlepost">
        <div class='step' data-step='1'>
            <div class="explain">
            <p><strong>The Asymmetric Phase</strong></p>
          </div>
        </div>
        <div class='step' data-step='2'>
            <div class="explain">
            <p>During the asymmetric phase, the parties will make use of the server keys. The Client has a copy of the public one (as possibly everyone else) for encryption, but it is expected that only the Server knows the private key for decryption.</p>
          </div>
        </div>
        <div class='step' data-step='3'>
            <div class="explain">
            <p>The Client uses the server public key and with a already negotiated asymmetric cipher encrypt the <strong>Pre-Master secret</strong>, which is another random number, and sends that to the Server.</p>
<div class="explain">
</div>
            </div>
        </div>
        <div class='step' data-step='4'>
            <div class="explain">
            <p>Now the Server uses the private key to decrypt the Pre-Master secret from the Client. The Pre-Master secret was safely passed through the public domain and now they both finally share their first secret. The asymmetric phase is completed.</p>
            </div>
        </div>
        <div class='step' data-step='5'>
            <div class="explain">
            <p><strong>The PRF Phase</strong></p>
            </div>
        </div>
        <div class='step' data-step='6'>
            <div class="explain">
            <p>Now both the Client and the Server have a key set, one of them totally secret to anyone else, that they can use in a symmetric procedure. All that can be encrypted with that set of values can be decrypted with the same set by reversing the encrypting operation.</p>
            </div>
        </div>        
        <div class='step' data-step='7'>
            <div class="explain">
            <p>The Server and the Client create and share a Master secret. The Master secret is the last key that they will use to create the session keys.</p>
            </div>
        </div>
        <div class='step' data-step='8'>
            <div class="explain">
            <p>The Server and the Client create and share Master secret. The Master secret is the last key that they will use to create the session keys.</p>
            </div>
        </div>
        <div class='step' data-step='9'>
            <div class="explain">
            <p>The Server and the Client create and share Master secret. The Master secret is the last key that they will use to create the session keys.</p>
            </div> 
        </div>
    </div>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
</section>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/threejs/v104/three.v104.min.js %}"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/D3js/v7.8.5/d3.v7.min.js %}"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/scrollama/v2.1.2/scrollama.v2.min.js %}"></script>
<script src="{{ site.baseurl }}{% link mngassets/vendor/js/stickyfill/v2.1.0/stickyfill.v2.min.js %}"></script>
<script type="module"  src="{{ site.baseurl }}{% link mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/js/scrollama-setup.js %}"></script>



#### *Client-side Pre-Master Secret Asymmetric Encryption*

To start the Handshake, our Client sends some information into the public Internet hoping that it will reach the intended Server.

In general, the "letter" sent to the Server is very basic, and of no harm for the concerned parties:

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - client asymmetric encryption.svg %}" style="width:100%;">


So, our Client sends that Hello letter with the client random and waits.


<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - clientPREMASTER2server airplane.png %}" style="width:100%;">



#### *Server-side Pre-Master Secret Assymetric Decryption*

That was the client hello but what happens on the other side? The server also responds with a "hello" letter.

Let's see what it contains:


  <img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - server asymmetric decryption.svg %}" style="width:100%;">
<br/>
<br/>
<br/>
<br/>


#### *Server-side First Message Symetric Encryption*


So, our Server sends back a Hello letter to the Client. 

  <img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - server symmetric encryption.svg %}" style="width:100%;">



Immediately after it sends a message indicating that this is all to be shared in the Server Hello, and waits.

<br/>
<br/>
<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - serverMESSAGE2client airplane.png %}" style="width:100%;">
<br/>
<br/>
<br/>

#### *Client-side First Message: Symetric Decryption*

<img src="{{site.baseurl}}{% link /mngassets/posts/2024-05-27-tls-ssl-v1.2-handshake-made-simple-session-keys-generation/img/TLS - client symmetric decryption.svg %}" style="width:100%;">

# Tada!

The "tada" moment consists in the beginning and completion of the fourth type of exchange between the parties, the Application Data, with fully encrypted information across a public domain, with no-one able to understand what it reads. Great, eh? 


# Final Remarks

The TLS / SSL handshake is a very fascinating solution to the security on the web. The procedure last just miliseconds, but there are a lot of things going on. That is why this procedure is sometimes difficult to understand.

Here in this post I just focused on a very specific section of the TLS handshake in its more popular version to date. Bear in mind that there is already a new version of the TLS that it is meant to replace the existing one. But this might take a few years from the time of this writing before it is completed faced out.

If you want to know more about the TLS, there is a lot of material you can find online. However, there are two that have impressed me the most:

##### KHAN ACADEMY

An excellent material, with exercises you can do on the fly, and a detailed discussion of the many aspects around the TLS handshake. No many can rival that quality of the material prepared by the Khan Academy team. The material goes beyond the TLS handshake by keeping this topic as a subtitle of Internet Security. Highly recommended.

**Find more at** [Online Data Security in Khan Academy](https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:online-data-security)


##### PRACTICAL NETWORKING

If what you want is to get a deep knowledge of the TLS itself, have a look at the cyphers used in the procedure, and many other details, including the new versions of TLS, you might find Practical Networking channel and courses probably a better choice. 

Practical Networking is a project by Ed Harmoush and it is not only a good youtube channel but also a very good course. Go for this one if you are into nets. Very clear and detailed.

**Find more at** [Practical Networking youtube channel](https://www.youtube.com/@PracticalNetworking)

**Or visit the Ed Harmoush'Sf course**, [Practical Networking course - About -](https://www.practicalnetworking.net/about/)


----

For the rest, I just hope you enjoyed this reading. Meanwhile, happy coding!



